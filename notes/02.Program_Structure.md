## Program Structure

### 2.1 Names

函数、变量、常量、类型、语句标签（statement labels）和包的命名遵循一个简单的规则：以一个字母（Unicode 认作为字母的都是）或下划线开头，然后可以有任意数量的字母、数字和下划线；大小写是敏感的；

Go 有 25 个关键字，只能在语法正确的方式使用且不能用作命名：

```
break			default				func		interface		select
case			defer				go			map				struct
chan			else				goto		package			switch
const			fallthrough			if			range			type
continue		for					import		return			var
```

另外，还有三组预声明的命名，像 `int` 和 `true`，作为内置常量、类型和函数：

```
Constants:		true false iota nil
Types:			int int8 int16 int32 int64
				uint uint8 uint16 uint32 uint64 uintptr
				float32 float64 complex128 complex64
				bool byte rune string error
Functions:		make len cap new append copy close delete
				complex real imag
				panic recover
```

一个名字的首字母决定了其越过包边界的可见性；如果名字是大写字母开头的，则被导出，也就是在自己包外其可见和读取的，并可以被其他部分的程序引用，就先 `fmt` 包中的 `Printf`；包名通常是小写的；

名字的长度没有限制，一般一个变量的作用域越大，其名字应该越长越有意义；

文体上，Go 程序员使用驼峰命名法命名组合单词；首字母缩略词例如 `ASCII`（acronyms，可以读成一个单词的首字母缩略词）、`HTML`（initialism，读成单个字母的首字母缩略词）通常保持同样的大小写；因此一个函数可以是 `htmlEscape`、`HTMLEscape` 或 `escapeHTML` 而不是 ~~`escapeHtml`~~；

### 2.2 Declarations

有四种重要的生命形式：`var`、`const`、`type` 和 `func`；

### 2.3 Variables

```
var name type = expression
```

`type` 或者 `= expression` 其中之一可以省略，但不能同时；如果 `type` 省略，将通过初始化表达式来推断变量的类型；如果表达式省略，初始值将是指定类型的零值，数字为 `0`、布尔类型 `false`、字符串 `""` 以及 `nil` 赋值给接口（interfaces）和引用类型（`slice`、`pointer`、`map`、`channel` 和 `function`）；一个集合类型例如数组或者结构体的零值，即所有其元素或字段的自己的零值；

使用匹配的表达式列表，在单个声明中可以声明并可选地初始化一组变量；省略类型允许使用不同类型声明多个变量：

```go
var i, j, k int					// int, int, int
var b, f, s = true, 2.3, "four"	// bool, float64, string
```

初始化值可以是字面量（literal values）或者任意表达式；包级变量在 `main` 函数开始前初始化，局部变量在函数执行期间遇到声明时初始化；

一组变量也可以通过调用返回多个值的函数进行初始化：

```go
var f, err = os.Open(name) // os.Open returns a file and an error
```

#### 2.3.1 Short Variable Declarations

在函数中，短变量声明（short variable declaration）是一种可选的声明和初始化局部变量的形式；

```
name := expression
```

`name` 的类型通过 `expression` 的类型推断得出；

由于其简洁和灵活性，短变量声明被用作大多数局部变量的声明和初始化；一个 `var` 声明倾向于需要一个显式的类型与其初始化表达式的类型形式不一样的局部变量、或者当变量可能稍后会被赋值，当前初始化的值并不那么重要时；

```go
i := 100					// an int
var boiling float64 = 100	// a float64

var names []string
var err error
var p Point
```

和 `var ` 声明一样，在一句短变量声明中可以声明和初始化多个变量，

```go
i, j := 0, 1
```

但是多初始化表达式的声明应该只在其帮助可读性时使用，比如短而自然的分组，例如 `for` 循环的初始化部分；

`:=` 是一个声明，而 `=` 是一个赋值；不要将多变量声明与元组赋值混淆：

```go
i, j = j, i // swap values of i and j
```

**有一点很微妙很重要：**短变量声明无需声明左手端所有变量；如果其中某些已经在相同的词法块（lexical block）中声明过了，那么短变量声明对这些变量表现的像赋值一样；

```go
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)
```

但是短变量声明至少声明一个新变量，例如下方代码无法编译：

```go
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
```

*外部块中的声明会被忽略；*

#### 2.3.2 Pointers

如果声明变量 `var x int`，表达式 `&x`（`x` 的地址）产生一个指向整型变量的指针，即 `*int` 类型的一个值，叫做 ”pointer to int”；如果该值叫做 `p`，则称之为 “p points to x”，或者 “p contains the address of x”；`p` 指向的变量写作 `*p`；表达式 `*p` 产生那个变量的值，一个整型；由于 `*p` 表示一个变量，它同样可以出现在赋值运算的左手边，该赋值运算更新该变量的值；

```go
x := 1
p := &x			// p, of type *int, points to x
fmt.Println(*p)	// "1"
*p = 2			// equivalent to x = 2
fmt.Println(x)	// "2"
```

表示变量的表达式是唯一可以使用取地址运算 `&` 的表达式；

任何类型的指针的零值都是 `nil`；两个指针只有在同时指向相同变量或者同为 `nil` 时相等；

```go
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil)	// "true false false"
```

一个函数返回一个局部变量的地址是完全安全的；调用函数 `f` 创造的局部变量 `v`，就算调用结束它保持存在，指针 `p` 仍然引用它：

```go
var p = f()

func f() *int {
	v := 1
	return &v
}
```

每次 `f` 的调用返回不同的值：

```go
fmt.Println(f() == f())	// "false"
```

除了指针创建别名，当拷贝引用类型的值时也会产生别名，例如 `slices`、`maps`、`channels` 甚至 `structs`、`arrays` 和包含这些类型的接口（interfaces）；

`flag` 包用于处理命令行参数，可以将命令行的参数值赋值给特定的变量；

```go
var n = flag.Bool("n", false, "omit trailing newline")
var sep = flag.String("s", " ", "separator")
```

函数 `flag.Bool` 创建一个 `flag` 布尔类型变量；第一个参数是命令行 `flag` 的名字，第二参数是其默认值，第三个参数是当用户提供错误的参数、错误的 `flag` 或者 `-h` 或 `-help` 时的打印信息；

当程序开始时，在使用 `flag` 之前必须先调用 `flag.Parse`，这样 `flag` 变量将从命令行替换其默认值；非 `flag` 的命令行参数可以从 `flag.Args()` 中获取，它是字符串的切片类型；当 `flag.Parse` 发生错误，其打印使用帮助信息，并调用 `os.Exit(2)` 终止程序；

#### 2.3.3 The new Function

可以使用内置函数 `new` 创建变量；表达式 `new(T)` 创建一个类型 `T` 的匿名变量，初始化为 `T` 的零值并返回它的地址，即类型 `*T` 的值；

```go
p := new(int)	// p, of type *int, points to an unnamed int variable
fmt.Println(*p)	// "0"
*p = 2			// sets the unnamed int to 2
fmt.Println(*p)	// "2"
```

可以在表达式中使用 `new(T)`；`new` 只是一种语法便利，而不是基本概念；

下次函数拥有完全相同的行为：

```go
func newInt() *int {
	return new(int)
}

func newInt() *int {
	var dummy int
	return &dummy
}
```

每一次调用 `new` 返回不同的具有唯一地址的变量：

```go
p := new(int)
q := new(int)
fmt.Println(p == q)	// "false"
```

**有一条除外：**两个变量的类型没有携带任何信息，并且大小为 0，例如 `struct{}` 和 `[0]int`，基于实现，可能会有相同的地址；

由于 `new` 是一个预置函数，而不是关键字，在函数中可以为其它东西重新定义该名称：

```go
func delta(old, new int) int {
    return new - old
}
```

当然，在 `delta` 中，内置 `new` 函数不再可用；

#### 2.3.4 Lifetime of Variables

